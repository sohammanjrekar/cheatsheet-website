<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Heap cheatsheet</title>
    <link rel="shortcut icon" href="../../assets/img/mainlogo.jpg" type="image/x-icon">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous" />
    <link rel="stylesheet" href="../../assets/css/style.css" />
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3"
        crossorigin="anonymous"></script>
    <link rel="stylesheet" href="../../myDesigns/assets/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,300italic,400italic,700italic">
    <link rel="stylesheet" href="../../myDesigns/assets/fonts/font-awesome.min.css">
    <link rel="stylesheet" href="../../myDesigns/assets/fonts/simple-line-icons.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.9.1/font/bootstrap-icons.css" />
    <link rel="stylesheet" href="../../assets/prismjs/prism.css" />
    <script src="../../assets/prismjs/prism.js"></script>
    <style>
        .scroll-to-top {
            background-color: #f77b50 !important;
            text-decoration: none !important;
        }

        .scroll-to-top:hover {
            background: #f77b50 !important;
            text-decoration: none !important;
        }

        footer .scroll-to-top {
            text-decoration: none !important;
        }

        li img {
            width: 100%
        }
    </style>
</head>

<body id="page-top">
    <nav class="navbar fixed-top navbar-expand-lg navbar-dark" style="background-color: rgb(1,4,45);color:white;">
        <div class="container-fluid">
            <a class="navbar-brand" href="../../index.html">
                <img src="../../assets/img/mainlogo.jpg" alt="" style="height: 8vh;"> Cheatbook
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="../../index.html">Home</a>
                    </li>
                    <!-- web develpoment -->
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown"
                            aria-expanded="false">
                            WebDev
                        </a>
                        <ul class="dropdown-menu multi-column columns-2">
                            <div class="row">
                                <div class="col-sm-6">
                                    <ul class="multi-column-dropdown">
                                        <li><a class="dropdown-item" href="../webdev/html.html">HTML</a></li>
                                        <li><a class="dropdown-item" href="../webdev/css.html">CSS</a></li>
                                        <li><a class="dropdown-item" href="../webdev/javascript.html">JavaScript</a>
                                        </li>
                                        <li><a class="dropdown-item" href="../webdev/react.html">Reactjs</a></li>
                                        <li><a class="dropdown-item" href="../webdev/nextjs.html">Nextjs</a></li>
                                        <li><a class="dropdown-item" href="../webdev/angularjs.html">Angularjs</a></li>
                                        <li><a class="dropdown-item" href="../webdev/angular.html">Angular</a></li>
                                        <li><a class="dropdown-item" href="../webdev/Vuejs.html">vuejs</a></li>
                                        <li><a class="dropdown-item" href="../webdev/redux.html">Redux</a></li>
                                    </ul>
                                </div>
                                <div class="col-sm-6">
                                    <ul class="multi-column-dropdown">
                                        <li><a class="dropdown-item" href="../webdev/flask.html">Flask</a></li>
                                        <li><a class="dropdown-item" href="../webdev/django.html">Django</a></li>
                                        <li><a class="dropdown-item" href="../webdev/php.html">PHP</a></li>
                                        <li><a class="dropdown-item" href="../webdev/nodejs.html">Nodejs</a></li>
                                        <li><a class="dropdown-item" href="../webdev/expressjs.html">Expressjs</a></li>
                                        <li><a class="dropdown-item" href="../webdev/fastapi.html">FastAPI</a></li>
                                        <li>
                                            <hr class="dropdown-divider" />
                                        </li>
                                        <li><a class="dropdown-item" href="../webdev/bootstrap.html">Bootstrap</a></li>
                                        <li><a class="dropdown-item" href="../webdev/tailwindcss.html">Tailwind css</a>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </ul>
                    </li>
                    <!-- programming -->
                    <li class="nav-item dropdown mx-1">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown"
                            aria-expanded="false">
                            Programming</a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="cplus.html">C++</a></li>
                            <li><a class="dropdown-item" href="c.html">C</a></li>
                            <li><a class="dropdown-item" href="java.html">Java</a></li>
                            <li><a class="dropdown-item" href="python.html">Python</a></li>
                            <li><a class="dropdown-item" href="perl.html">Perl</a></li>
                            <li><a class="dropdown-item" href="ruby.html">Ruby</a></li>
                            <li>
                                <hr class="dropdown-divider" />
                            </li>
                            <li><a class="dropdown-item" href="dsa.html">DSA</a></li>
                        </ul>
                    </li>
                    <!-- Machine learning -->
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown"
                            aria-expanded="false">
                            ML</a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="../ML/numpy.html">Numpy</a></li>
                            <li><a class="dropdown-item" href="../ML/pandas.html">Pandas</a></li>
                            <li><a class="dropdown-item" href="../ML/matplotlib.html">Matplotlib</a></li>
                            <li><a class="dropdown-item" href="../ML/tensorflow.html">Tensorflow</a></li>
                            <li><a class="dropdown-item" href="../ML/seaborn.html">Seaborn</a></li>
                            <li><a class="dropdown-item" href="../ML/powerbi.html">Power BI</a></li>
                            <li><a class="dropdown-item" href="../ML/r.html">R language</a></li>
                            <li><a class="dropdown-item" href="../ML/scipy.html">scipy</a></li>
                            <li><a class="dropdown-item" href="../ML/sklearn.html">sklearn</a></li>
                            <li><a class="dropdown-item" href="../ML/tableau.html">tableau</a></li>
                            <li>
                                <hr class="dropdown-divider" />
                            </li>
                            <li><a class="dropdown-item" href="../ML/machinelearning.html">Machine Learning</a></li>
                        </ul>
                    </li>
                    <!-- databases -->
                    <li class="nav-item dropdown mx-1">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown"
                            aria-expanded="false">Databases</a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="../database/mysql.html">MYSQL</a></li>
                            <li><a class="dropdown-item" href="../database/mongodb.html">MongoDB</a></li>
                            <li><a class="dropdown-item" href="../database/postsql.html">PostgrelSQL</a></li>
                        </ul>
                    </li>
                    <!-- App development-->
                    <li class="nav-item dropdown mx-1">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown"
                            aria-expanded="false">AppDev</a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="../appdev/android.html">Android</a></li>
                            <li><a class="dropdown-item" href="../appdev/kotlin.html">Kotlin</a></li>
                            <li><a class="dropdown-item" href="../appdev/reactnative.html">ReactNative</a></li>
                        </ul>
                    </li>
                    <!-- Devops -->
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown"
                            aria-expanded="false">DevOps</a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="../devops/docker.html">Docker</a></li>
                            <li><a class="dropdown-item" href="../devops/jenkins.html">jenkins</a></li>
                            <li><a class="dropdown-item" href="../devops/kubernetes.html">kubernetes</a></li>
                            <li><a class="dropdown-item" href="../devops/maven.html">Maven</a></li>
                            <li><a class="dropdown-item" href="../devops/git.html">Git</a> </li>
                            <li><a class="dropdown-item" href="../devops/bamboo.html">Bamboo</a> </li>
                            <li><a class="dropdown-item" href="../devops/Vagrant.html">Vagrant</a> </li>
                            <li><a class="dropdown-item" href="../devops/Prometheus.html">Prometheus</a> </li>
                        </ul>
                    </li>
                    <li class="nav-item"><a class="nav-link" href="../../about.html">About Us</a></li>
                </ul>
                <a href="../../myDesigns/index.html">
                    <div class="button btn1 mx-1" style="font-size: 1em;">My Designs</div>
                </a>
            </div>
        </div>
    </nav>
    <!-- mid part -->
    <nav class="mt-5 p-2 headline" style="background:linear-gradient(to top right, #fb5475 0%, #f77b50 59%);">
        <div class="text-center " style="margin-top:5vh;"><img style="margin-right:2vh;"
                src="../../assets/img/mainlogo.jpg" alt="" />Heap cheatsheet
        </div>
    </nav>
    <div class="container">
        <div class="p-5 mb-4 bg-light rounded-3 jumbo mt-2">
            <div class="container-fluid py-3">
                <h1 class="display-5 fw-bold">Heap</h1>
                <div class="row">
                    <div class="col-md-6">
                        <p class="fs-4">
                            A heap is a specialized tree-based data structure that satisfies the heap property: If A is a parent node of B, then the key (the value) of node A is ordered with respect to the key of node B with the same ordering applying across the heap.
                        </p>
                    </div>
                    <div class="col-md-6 text-center">
                        <img src="../../assets/img/dsa/heap.png" alt="" style="height:100%;width:100%;" />
                    </div>
                </div>
                <button class="btn btn1" type="button" data-bs-toggle="offcanvas" data-bs-target="#o1"
                    aria-controls="o1">
                    Read More...
                </button>
                <a href="https://docs.oracle.com/en/java/javase/11/docs/api/index.html">
                    <div class="button btn1 mx-1 text-center" style="font-size: 1em;width:5em;">Docs</div>
                </a>
                <div class="offcanvas offcanvas-start" data-bs-scroll="true" tabindex="-1" id="o1"
                    aria-labelledby="offcanvasWithBothOptionsLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="offcanvasWithBothOptionsLabel">
                            Binary Tree
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        Types of heaps:
                        Generally, heaps are of two types.
                        
                        Max-Heap: 
                        In this heap, the value of the root node must be the greatest among all its child nodes and the same thing must be done for its left and right sub-tree also.
                        
                        
                        Min-Heap: 
                        In this heap, the value of the root node must be the smallest among all its child nodes and the same thing must be done for its left ans right sub-tree also.
                        
                        Types of Heap Data Structure
                        Types of Heap Data Structure
                        
                        Characteristics of Heap:
                        Heap has the following characteristics:
                        The system assigns a unique heap identifier to each heap within the activation group. The heap identifier for the default heap is always zero. A storage management-bindable API, called by a program or procedure, uses the heap identifier to identify the heap on which it is to act. The bindable API must run within the activation group that owns the heap.
                        The size of a heap is dynamically extended to satisfy allocation requests. The maximum size of the heap is (4GB – 512KB). This is the maximum heap size if the total number of allocations (at any one time) does not exceed 128 000.
                        The maximum size of any single allocation from a heap is limited to (16MB – 64KB).
                        Operations Supported by Heap:
                        Operations supported by min – heap and max – heap are same. The difference is just that min-heap contains minimum element at root of the tree and max – heap contains maximum element at the root of the tree.
                    </div>
                </div>
            </div>
        </div>
        <ol>
            <!-- offcanvas -->
            <li>Types of Binary tree
                <ol type="A">
                    <li>
                        Types of Binary Tree based on the number of children
                        <div class="accordion" id="accordionExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingOne">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne">
                                        Full Binary Tree
                                    </button>
                                </h2>
                                <div id="collapseOne" class="accordion-collapse collapse" aria-labelledby="headingOne"
                                    data-bs-parent="#accordionExample">
                                    <div class="accordion-body">
                                        A Binary Tree is a full binary tree if every node has 0 or 2 children. The
                                        following are
                                        examples of a full binary tree. We can also say a full binary tree is a binary
                                        tree in
                                        which all nodes except leaf nodes have two children.
                                        <br><br>
                                        A full Binary tree is a special type of binary tree in which every parent
                                        node/internal
                                        node has either two or no children. It is also known as a proper binary tree.
                                        <img src="https://media.geeksforgeeks.org/wp-content/uploads/20221125111700/full.png"
                                            alt="">
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingTwo">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#c2" aria-expanded="false" aria-controls="c2">
                                        Degenerate (or pathological) tree
                                    </button>
                                </h2>
                                <div id="c2" class="accordion-collapse collapse" aria-labelledby="headingTwo"
                                    data-bs-parent="#accordionExample">
                                    <div class="accordion-body">
                                        A Tree where every internal node has one child. Such trees are performance-wise
                                        same as linked list. A degenerate or pathological tree is a tree having a single
                                        child either left or right.
                                        <img src="https://media.geeksforgeeks.org/wp-content/uploads/20221124105941/degeneratetree.png"
                                            alt="">
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingThree">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#c3" aria-expanded="false" aria-controls="c3">
                                        Skewed Binary Tree
                                    </button>
                                </h2>
                                <div id="c3" class="accordion-collapse collapse" aria-labelledby="headingThree"
                                    data-bs-parent="#accordionExample">
                                    <div class="accordion-body">
                                        A skewed binary tree is a pathological/degenerate tree in which the tree is
                                        either dominated by the left nodes or the right nodes. Thus, there are two types
                                        of skewed binary tree: left-skewed binary tree and right-skewed binary tree.
                                        <img src="https://media.geeksforgeeks.org/wp-content/uploads/20221130172501/skewed1.png"
                                            alt="">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </li>
                    <li>Types of Binary Tree On the basis of the completion of levels
                        <div class="accordion" id="accordionExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingOne">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#collapseOne1" aria-expanded="false"
                                        aria-controls="collapseOne">
                                        Complete Binary Tree
                                    </button>
                                </h2>
                                <div id="collapseOne1" class="accordion-collapse collapse" aria-labelledby="headingOne"
                                    data-bs-parent="#accordionExample">
                                    <div class="accordion-body">
                                        A Binary Tree is a Complete Binary Tree if all the levels are completely filled
                                        except possibly the last level and the last level has all keys as left as
                                        possible.
                                        <br><br><br>
                                        A complete binary tree is just like a full binary tree, but with two major
                                        differences:
                                        <br><br>
                                        Every level must be completely filled<br>
                                        All the leaf elements must lean towards the left.<br>
                                        The last leaf element might not have a right sibling i.e. a complete binary tree
                                        doesn't have to be a full binary tree.<br><br>
                                        <img src="https://media.geeksforgeeks.org/wp-content/uploads/20221130172411/completedrawio.png"
                                            alt="">
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingTwo">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#c21" aria-expanded="false" aria-controls="c2">
                                        Perfect Binary Tree
                                    </button>
                                </h2>
                                <div id="c21" class="accordion-collapse collapse" aria-labelledby="headingTwo"
                                    data-bs-parent="#accordionExample">
                                    <div class="accordion-body">
                                        A Binary tree is a Perfect Binary Tree in which all the internal nodes have two
                                        children and all leaf nodes are at the same level. <br><br>
                                        The following are examples of Perfect Binary Trees.
                                        <br><br>
                                        A perfect binary tree is a type of binary tree in which every internal node has
                                        exactly two child nodes and all the leaf nodes are at the same level.<br><br>
                                        <img src="https://media.geeksforgeeks.org/wp-content/uploads/20221124094547/perfect.png"
                                            alt="">
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingThree">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#c31" aria-expanded="false" aria-controls="c3">
                                        Balanced Binary Tree
                                    </button>
                                </h2>
                                <div id="c31" class="accordion-collapse collapse" aria-labelledby="headingThree"
                                    data-bs-parent="#accordionExample">
                                    <div class="accordion-body">
                                        A binary tree is balanced if the height of the tree is O(Log n) where n is the
                                        number of nodes. For Example, the AVL tree maintains O(Log n) height by making
                                        sure that the difference between the heights of the left and right subtrees is
                                        at most 1. Red-Black trees maintain O(Log n) height by making sure that the
                                        number of Black nodes on every root to leaf paths is the same and that there are
                                        no adjacent red nodes. Balanced Binary Search trees are performance-wise good as
                                        they provide O(log n) time for search, insert and delete. <br><br>
                                        <img src="https://media.geeksforgeeks.org/wp-content/uploads/20220612212939/UntitledDiagramdrawio-660x371.png"
                                            alt="">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </li>

                    <li>Some Special Types of Trees
                        <div class="accordion" id="accordionExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingOne">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#collapseOne12" aria-expanded="false"
                                        aria-controls="collapseOne">
                                        Binary Search Tree
                                    </button>
                                </h2>
                                <div id="collapseOne12" class="accordion-collapse collapse" aria-labelledby="headingOne"
                                    data-bs-parent="#accordionExample">
                                    <div class="accordion-body">
                                        Binary Search Tree is a node-based binary tree data structure that has the
                                        following properties:
                                        <br><br><br>
                                        The left subtree of a node contains only nodes with keys lesser than the node’s
                                        key.<br><br>
                                        The right subtree of a node contains only nodes with keys greater than the
                                        node’s key.<br><br>
                                        The left and right subtree each must also be a binary search tree.
                                        <br><br>
                                        <img src="https://media.geeksforgeeks.org/wp-content/uploads/20221125114604/BST.png"
                                            alt="">
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingTwo">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#c212" aria-expanded="false" aria-controls="c2">
                                        AVL Tree
                                    </button>
                                </h2>
                                <div id="c212" class="accordion-collapse collapse" aria-labelledby="headingTwo"
                                    data-bs-parent="#accordionExample">
                                    <div class="accordion-body">
                                        AVL tree is a self-balancing Binary Search Tree (BST) where the difference
                                        between heights of left and right subtrees cannot be more than one for all
                                        nodes. <br><br>
                                        <img src="https://media.geeksforgeeks.org/wp-content/uploads/20221124093021/avl.png"
                                            alt="">
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingThree">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#c312" aria-expanded="false" aria-controls="c3">
                                        Red Black Tree
                                    </button>
                                </h2>
                                <div id="c312" class="accordion-collapse collapse" aria-labelledby="headingThree"
                                    data-bs-parent="#accordionExample">
                                    <div class="accordion-body">
                                        A red-black tree is a kind of self-balancing binary search tree where each node
                                        has an extra bit, and that bit is often interpreted as the color (red or black).
                                        These colors are used to ensure that the tree remains balanced during insertions
                                        and deletions. Although the balance of the tree is not perfect, it is good
                                        enough to reduce the searching time and maintain it around O(log n) time, where
                                        n is the total number of elements in the tree. This tree was invented in 1972 by
                                        Rudolf Bayer. <br><br>
                                        <img src="https://media.geeksforgeeks.org/wp-content/uploads/20221124112517/redblack.png"
                                            alt="">
                                    </div>
                                </div>
                            </div>



                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingThree">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#c313" aria-expanded="false" aria-controls="c3">
                                        B – Tree
                                    </button>
                                </h2>
                                <div id="c3123" class="accordion-collapse collapse" aria-labelledby="headingThree"
                                    data-bs-parent="#accordionExample">
                                    <div class="accordion-body">
                                        B-Tree is a self-balancing search tree. In most of the other self-balancing
                                        search trees (like AVL and Red-Black Trees), it is assumed that everything is in
                                        the main memory.
                                        <br><br> To understand the use of B-Trees, we must think of the huge amount of
                                        data that cannot fit in the main memory. When the number of keys is high, the
                                        data is read from the disk in the form of blocks. Disk access time is very high
                                        compared to the main memory access time. The main idea of using B-Trees is to
                                        reduce the number of disk accesses. Most of the tree operations (search, insert,
                                        delete, max, min, ..etc ) require O(h) disk accesses where h is the height of
                                        the tree. B-tree is a fat tree. The height of B-Trees is kept low by putting the
                                        maximum possible keys in a B-Tree node. Generally, the B-Tree node size is kept
                                        equal to the disk block size. Since the height of the B-tree is low so total
                                        disk accesses for most of the operations are reduced significantly compared to
                                        balanced Binary Search Trees like AVL Tree, Red-Black Tree, etc. <br><br>
                                        <img src="https://media.geeksforgeeks.org/wp-content/uploads/20200506235136/output253.png"
                                            alt="">
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingThree">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#c3124" aria-expanded="false" aria-controls="c3">
                                        Segment Tree
                                    </button>
                                </h2>
                                <div id="c3124" class="accordion-collapse collapse" aria-labelledby="headingThree"
                                    data-bs-parent="#accordionExample">
                                    <div class="accordion-body">
                                        In computer science, a Segment Tree, also known as a statistic tree, is a tree
                                        data structure used for storing information about intervals, or segments. It
                                        allows querying which of the stored segments contain a given point. It is, in
                                        principle, a static structure; that is, it’s a structure that cannot be modified
                                        once it’s built. A similar data structure is the interval tree.
                                        <br><br>
                                        A segment tree for a set I of n intervals uses O(n log n) storage and can be
                                        built in O(n log n) time. Segment trees support searching for all the intervals
                                        that contain a query point in time O(log n + k), k being the number of retrieved
                                        intervals or segments.

                                        <br><br>
                                        <img src="https://media.geeksforgeeks.org/wp-content/uploads/20221125121942/segment.png"
                                            alt="">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </li>
                </ol>

            </li>
            <!-- offcanvas -->
            <li>
                Inorder Traversal<button class="btn btn1" type="button" data-bs-toggle="offcanvas"
                    data-bs-target="#offcanvasBottom2" aria-controls="offcanvasBottom">Read more...</button>
                <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvasBottom2"
                    aria-labelledby="offcanvasBottomLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="offcanvasBottomLabel">Inorder Traversal</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body small">
                        1) Traverse the left subtree, i.e., call Inorder(left->subtree)<br><br>
                        2) Visit the root.<br><br>
                        3) Traverse the right subtree, i.e., call Inorder(right->subtree)<br><br>
                        Uses of Inorder Traversal:<br><br>
                        In the case of binary search trees (BST), Inorder traversal gives nodes in non-decreasing order.
                        To get nodes of BST in non-increasing order, a variation of Inorder traversal where Inorder
                        traversal is reversed can be used. <br><br>
                        Time Complexity: O(N) <br><br>
                        Auxiliary Space: If we don’t consider the size of the stack for function calls then O(1)
                        otherwise O(h) where h is the height of the tree. <br><br>
                    </div>
                </div>

                <pre class="language-java">
                    <code>
                        // Java program for different tree traversals
                        class Node {
                            int key;
                            Node left, right;
                        
                            public Node(int item)
                            {
                                key = item;
                                left = right = null;
                            }
                        }
                        
                        class BinaryTree {
                            // Root of Binary Tree
                            Node root;
                        
                            BinaryTree() { root = null; }
                        
                            /* Given a binary tree, print its nodes in inorder*/
                            void printInorder(Node node)
                            {
                                if (node == null)
                                    return;
                        
                                /* first recur on left child */
                                printInorder(node.left);
                        
                                /* then print the data of node */
                                System.out.print(node.key + " ");
                        
                                /* now recur on right child */
                                printInorder(node.right);
                            }
                        
                            // Wrappers over above recursive functions
                            void printInorder() { printInorder(root); }
                        
                            // Driver code
                            public static void main(String[] args)
                            {
                                BinaryTree tree = new BinaryTree();
                                tree.root = new Node(1);
                                tree.root.left = new Node(2);
                                tree.root.right = new Node(3);
                                tree.root.left.left = new Node(4);
                                tree.root.left.right = new Node(5);
                        
                                // Function call
                                System.out.println(
                                    "\nInorder traversal of binary tree is ");
                                tree.printInorder();
                            }
                        }
                        
                </code>
                </pre>
            </li>
            <li>Preorder Traversal
                <button class="btn btn1" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasBottom5"
                    aria-controls="offcanvasBottom">Read more...</button>
                <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvasBottom5"
                    aria-labelledby="offcanvasBottomLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="offcanvasBottomLabel">PriorityQueue use for Queue</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body small">
                        Visit the root. <br>
                        Traverse the left subtree, i.e., call Preorder(left->subtree)<br>
                        Traverse the right subtree, i.e., call Preorder(right->subtree) <br><br><br>

                        Uses of Preorder:<br>
                        Preorder traversal is used to create a copy of the tree. Preorder traversal is also used to get
                        prefix expressions on an expression tree.
                        <br><br><br>
                        Time Complexity: O(N)<br>
                        Auxiliary Space: If we don’t consider the size of the stack for function calls then O(1)
                        otherwise O(h) where h is the height of the tree. <br><br>
                    </div>
                </div>
                <pre class="language-java">
    <code>     
        // Java program for different tree traversals
 
/* Class containing left and right child of current
   node and key value*/
class Node {
    int key;
    Node left, right;
 
    public Node(int item)
    {
        key = item;
        left = right = null;
    }
}
 
class BinaryTree {
    // Root of Binary Tree
    Node root;
 
    BinaryTree() { root = null; }
   
    /* Given a binary tree, print its nodes in preorder*/
    void printPreorder(Node node)
    {
        if (node == null)
            return;
 
        /* first print data of node */
        System.out.print(node.key + " ");
 
        /* then recur on left subtree */
        printPreorder(node.left);
 
        /* now recur on right subtree */
        printPreorder(node.right);
    }
 
    // Wrappers over above recursive functions
    void printPreorder() { printPreorder(root); }
 
    // Driver code
    public static void main(String[] args)
    {
        BinaryTree tree = new BinaryTree();
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);
 
          // Function call
        System.out.println(
            "Preorder traversal of binary tree is ");
        tree.printPreorder();
    }
}
    </code>
</pre>

            </li>





            <li>Postorder Traversal
                <button class="btn btn1" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasBottom585"
                    aria-controls="offcanvasBottom">Read more...</button>
                <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvasBottom585"
                    aria-labelledby="offcanvasBottomLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="offcanvasBottomLabel">Postorder Traversal</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body small">
                        1) Traverse the left subtree, i.e., call Postorder(left->subtree)<br>
                        2) Traverse the right subtree, i.e., call Postorder(right->subtree)<br>
                        3) Visit the root<br>
                        <br><br>
                        Uses of Postorder:<br>
                        Postorder traversal is used to delete the tree. Please see the question for the deletion of a
                        tree for details. Postorder traversal is also useful to get the postfix expression of an
                        expression tree
                        <br>
                        <br><br>
                        Time Complexity: O(N)<br><br>
                        Auxiliary Space: If we don’t consider the size of the stack for function calls then O(1)
                        otherwise O(h) where h is the height of the tree.
                    </div>
                </div>

                <pre class="language-java">
            <code>     
                // Java program for different tree traversals

                /* Class containing left and right child of current
                node and key value*/
                class Node {
                    int key;
                    Node left, right;
                
                    public Node(int item)
                    {
                        key = item;
                        left = right = null;
                    }
                }
                
                class BinaryTree {
                    // Root of Binary Tree
                    Node root;
                
                    BinaryTree() { root = null; }
                
                    /* Given a binary tree, print its nodes according to the
                    "bottom-up" postorder traversal. */
                    void printPostorder(Node node)
                    {
                        if (node == null)
                            return;
                
                        // first recur on left subtree
                        printPostorder(node.left);
                
                        // then recur on right subtree
                        printPostorder(node.right);
                
                        // now deal with the node
                        System.out.print(node.key + " ");
                    }
                
                    // Wrappers over above recursive functions
                    void printPostorder() { printPostorder(root); }
                
                    // Driver code
                    public static void main(String[] args)
                    {
                        BinaryTree tree = new BinaryTree();
                        tree.root = new Node(1);
                        tree.root.left = new Node(2);
                        tree.root.right = new Node(3);
                        tree.root.left.left = new Node(4);
                        tree.root.left.right = new Node(5);
                
                        // Function call
                        System.out.println(
                            "\nPostorder traversal of binary tree is ");
                        tree.printPostorder();
                    }
                }
                
            </code>
        </pre>


            </li>








            <li> Level Order Binary Tree Traversal using Recursion
                <button class="btn btn1" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasBottom5857"
                    aria-controls="offcanvasBottom">Read more...</button>
                <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvasBottom5857"
                    aria-labelledby="offcanvasBottomLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="offcanvasBottomLabel">Level Order Binary Tree Traversal using
                            Recursion</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body small">
                        Print the level order traversal of the tree using recursive function to traverse all nodes of a
                        level. Find height of tree and run depth first search and maintain current height, print nodes
                        for every height from root and for 1 to height and match if the current height is equal to
                        height of the iteration then print node’s data.<br><br><br>
                        Follow the below steps to Implement the idea:
                        <br><br>
                        1) Run a for loop for counter i, i.e. current height from 1 to h (height of the tree).<br>
                        2) Use DFS to traverse the tree and maintain height for the current node.<br>
                        3) If the Node is NULL then return;<br>
                        4) If level is 1 print(tree->data);<br>
                        5) Else if the level is greater than 1, then<br>
                        Recursively call to for tree->left, level-1.<br>
                        Recursively call to for tree->right, level-1.<br><br><br>
                        Time Complexity: O(N2), where N is the number of nodes in the skewed tree. So time complexity of
                        printLevelOrder() is O(n) + O(n-1) + O(n-2) + .. + O(1) which is O(N2). <br><br>
                        Auxiliary Space: O(N) in the worst case. For a skewed tree, printGivenLevel() uses O(n) space
                        for the call stack. For a Balanced tree, the call stack uses O(log n) space, (i.e., the height
                        of the balanced tree).
                    </div>
                </div>

                <pre class="language-java">
            <code>     
                // Recursive Java program for level
                // order traversal of Binary Tree
                
                /* Class containing left and right child of current
                node and key value*/
                class Node {
                    int data;
                    Node left, right;
                    public Node(int item)
                    {
                        data = item;
                        left = right = null;
                    }
                }
                
                class BinaryTree {
                    // Root of the Binary Tree
                    Node root;
                
                    public BinaryTree() { root = null; }
                
                    /* function to print level order traversal of tree*/
                    void printLevelOrder()
                    {
                        int h = height(root);
                        int i;
                        for (i = 1; i <= h; i++)
                            printCurrentLevel(root, i);
                    }
                
                    /* Compute the "height" of a tree -- the number of
                    nodes along the longest path from the root node
                    down to the farthest leaf node.*/
                    int height(Node root)
                    {
                        if (root == null)
                            return 0;
                        else {
                            /* compute height of each subtree */
                            int lheight = height(root.left);
                            int rheight = height(root.right);
                
                            /* use the larger one */
                            if (lheight > rheight)
                                return (lheight + 1);
                            else
                                return (rheight + 1);
                        }
                    }
                
                    /* Print nodes at the current level */
                    void printCurrentLevel(Node root, int level)
                    {
                        if (root == null)
                            return;
                        if (level == 1)
                            System.out.print(root.data + " ");
                        else if (level > 1) {
                            printCurrentLevel(root.left, level - 1);
                            printCurrentLevel(root.right, level - 1);
                        }
                    }
                
                    /* Driver program to test above functions */
                    public static void main(String args[])
                    {
                        BinaryTree tree = new BinaryTree();
                        tree.root = new Node(1);
                        tree.root.left = new Node(2);
                        tree.root.right = new Node(3);
                        tree.root.left.left = new Node(4);
                        tree.root.left.right = new Node(5);
                
                        System.out.println("Level order traversal of"
                                        + "binary tree is ");
                        tree.printLevelOrder();
                    }
                }
                
            </code>
        </pre>
            </li>
            <li>Level Order Binary Tree Traversal Using Queue
                <button class="btn btn1" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasBottom448"
                    aria-controls="offcanvasBottom">Read more...</button>
                <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvasBottom448"
                    aria-labelledby="offcanvasBottomLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="offcanvasBottomLabel">Level Order Binary Tree Traversal Using
                            Queue</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body small">
                        For each node, first, the node is visited and then it’s child nodes are put in a FIFO queue.
                        Then again the first node is popped out and then it’s child nodes are put in a FIFO queue and
                        repeat until queue becomes empty.
                        <br><br><br>
                        Follow the below steps to Implement the above idea:
                        <br><br>
                        Create an empty queue q and push root in q.<br>
                        Run While loop until q is not empty. <br>
                        Initialize temp_node = q.front() and print temp_node->data.<br>
                        Push temp_node’s children i.e. temp_node -> left then temp_node -> right to q<br>
                        Pop front node from q.<br><br><br>Time Complexity: O(N) where n is the number of nodes in the
                        binary tree.<br><br>
                        Auxiliary Space: O(N) where n is the number of nodes in the binary tree.
                    </div>
                </div>
                <pre class="language-java">
<code>
    // Iterative Queue based Java program
    // to do level order traversal
    // of Binary Tree
    
    /* importing the inbuilt java classes
    required for the program */
    import java.util.LinkedList;
    import java.util.Queue;
    
    /* Class to represent Tree node */
    class Node {
        int data;
        Node left, right;
    
        public Node(int item)
        {
            data = item;
            left = null;
            right = null;
        }
    }
    
    /* Class to print Level Order Traversal */
    class BinaryTree {
    
        Node root;
    
        /* Given a binary tree. Print
        its nodes in level order
        using array for implementing queue */
        void printLevelOrder()
        {
            Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();
            queue.add(root);
            while (!queue.isEmpty()) {
    
                /* poll() removes the present head.
                For more information on poll() visit
                http://www.tutorialspoint.com/java/
                util/linkedlist_poll.htm */
                Node tempNode = queue.poll();
                System.out.print(tempNode.data + " ");
    
                /*Enqueue left child */
                if (tempNode.left != null) {
                    queue.add(tempNode.left);
                }
    
                /*Enqueue right child */
                if (tempNode.right != null) {
                    queue.add(tempNode.right);
                }
            }
        }
    
        public static void main(String args[])
        {
            /* creating a binary tree and entering
            the nodes */
            BinaryTree tree_level = new BinaryTree();
            tree_level.root = new Node(1);
            tree_level.root.left = new Node(2);
            tree_level.root.right = new Node(3);
            tree_level.root.left.left = new Node(4);
            tree_level.root.left.right = new Node(5);
    
            System.out.println("Level order traversal of binary tree is - ");
            tree_level.printLevelOrder();
        }
    }
    
</code>
</pre>
            </li>


            <li>Find the Maximum Depth or Height of given Binary Tree
                <button class="btn btn1" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasBottom449"
                    aria-controls="offcanvasBottom">Read more...</button>
                <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvasBottom449"
                    aria-labelledby="offcanvasBottomLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="offcanvasBottomLabel">Level Order Binary Tree Traversal Using
                            Queue</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body small">
                        Given a binary tree, the task is to find the height of the tree. Height of the tree is the
                        number of edges in the tree from the root to the deepest node, Height of the empty tree is 0.
                        <br>
                        <br> <br>
                        Follow the below steps to Implement the idea: <br> <br>

                        Recursively do a Depth-first search. <br>
                        If the tree is empty then return -1 <br>
                        Otherwise, do the following <br>
                        Get the max depth of the left subtree recursively i.e. call maxDepth( tree->left-subtree) <br>
                        Get the max depth of the right subtree recursively i.e. call maxDepth( tree->right-subtree) <br>
                        Get the max of max depths of left and right subtrees and add 1 to it for the current node. <br>
                        max_depth = max(max dept of left subtree, max depth of right subtree) + 1 <br>
                        Return max_depth. <br> <br> Time Complexity: O(N) (Please see our post Tree Traversal for
                        details)
                        <br><br> Auxiliary Space: O(N) due to recursive stack.
                    </div>
                </div>
                <pre class="language-java">
<code>
    // Java program to find height of tree

// A binary tree node
class Node {
	int data;
	Node left, right;

	Node(int item)
	{
		data = item;
		left = right = null;
	}
}

class BinaryTree {
	Node root;

	/* Compute the "maxDepth" of a tree -- the number of
	nodes along the longest path from the root node
	down to the farthest leaf node.*/
	int maxDepth(Node node)
	{
		if (node == null)
			return 0;
		else {
			/* compute the depth of each subtree */
			int lDepth = maxDepth(node.left);
			int rDepth = maxDepth(node.right);

			/* use the larger one */
			if (lDepth > rDepth)
				return (lDepth + 1);
			else
				return (rDepth + 1);
		}
	}

	/* Driver program to test above functions */
	public static void main(String[] args)
	{
		BinaryTree tree = new BinaryTree();

		tree.root = new Node(1);
		tree.root.left = new Node(2);
		tree.root.right = new Node(3);
		tree.root.left.left = new Node(4);
		tree.root.left.right = new Node(5);

		System.out.println("Height of tree is "
						+ tree.maxDepth(tree.root));
	}
}

</code>
</pre>
            </li>
            <li>Deletion in a Binary Tree
                <button class="btn btn1" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasBottom4481"
                    aria-controls="offcanvasBottom">Read more...</button>
                <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvasBottom4481"
                    aria-labelledby="offcanvasBottomLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="offcanvasBottomLabel">Deletion in a Binary Tree</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body small">
                        Given a binary tree and a key, insert the key into the binary tree at the first position
                        available in level order.<br><br>
                        Time Complexity: O(V) where V is the number of nodes.<br><br>
                        Auxiliary Space: O(B), where B is the width of the tree and in the worst case we need to hold
                        all vertices of a level in the queue.
                    </div>
                </div>
                <pre class="language-java">
<code>
    // Java program to insert element in binary tree
import java.util.LinkedList;
import java.util.Queue;
public class GFG {

	/* A binary tree node has key, pointer to
	left child and a pointer to right child */
	static class Node {
		int key;
		Node left, right;

		// constructor
		Node(int key)
		{
			this.key = key;
			left = null;
			right = null;
		}
	}
	static Node root;
	static Node temp = root;

	/* Inorder traversal of a binary tree*/
	static void inorder(Node temp)
	{
		if (temp == null)
			return;

		inorder(temp.left);
		System.out.print(temp.key + " ");
		inorder(temp.right);
	}

	/*function to insert element in binary tree */
	static void insert(Node temp, int key)
	{

		if (temp == null) {
			root = new Node(key);
			return;
		}
		Queue&lt;Node&gt; q = new LinkedList&lt;Node&gt;();
		q.add(temp);

		// Do level order traversal until we find
		// an empty place.
		while (!q.isEmpty()) {
			temp = q.peek();
			q.remove();

			if (temp.left == null) {
				temp.left = new Node(key);
				break;
			}
			else
				q.add(temp.left);

			if (temp.right == null) {
				temp.right = new Node(key);
				break;
			}
			else
				q.add(temp.right);
		}
	}

	// Driver code
	public static void main(String args[])
	{
		root = new Node(10);
		root.left = new Node(11);
		root.left.left = new Node(7);
		root.right = new Node(9);
		root.right.left = new Node(15);
		root.right.right = new Node(8);

		System.out.print(
			"Inorder traversal before insertion:");
		inorder(root);

		int key = 12;
		insert(root, key);

		System.out.print(
			"\nInorder traversal after insertion:");
		inorder(root);
	}
}
</code>
</pre>
            </li>



            <li>Deletion in a Binary Tree
                <button class="btn btn1" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasBottom4487"
                    aria-controls="offcanvasBottom">Read more...</button>
                <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvasBottom4487"
                    aria-labelledby="offcanvasBottomLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="offcanvasBottomLabel">Deletion in a Binary Tree</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body small">
                        Given a binary tree, delete a node from it by making sure that the tree shrinks from the bottom
                        (i.e. the deleted node is replaced by the bottom-most and rightmost node). This is different
                        from BST deletion. Here we do not have any order among elements, so we replace them with the
                        last element.<br><br><br>
                        Algorithm:
                        <br><br>
                        Starting at the root, find the deepest and rightmost node in the binary tree and the node which
                        we want to delete. <br>
                        Replace the deepest rightmost node’s data with the node to be deleted. <br>
                        Then delete the deepest rightmost node.<br><br>
                        <img src="https://media.geeksforgeeks.org/wp-content/uploads/deletion-in-binary-tree.png"
                            alt="">
                        <br><br> Time complexity: O(n) where n is no number of nodes<br><br>
                        Auxiliary Space: O(n) size of queue<br><br>

                        Note: We can also replace the node’s data that is to be deleted with any node whose left and
                        right child points to NULL but we only use deepest node in order to maintain the Balance of a
                        binary tree.
                    </div>
                </div>
                <pre class="language-java">
<code>
    // Java program to delete element
// in binary tree
import java.util.LinkedList;
import java.util.Queue;

class GFG {

	// A binary tree node has key, pointer to
	// left child and a pointer to right child
	static class Node {
		int key;
		Node left, right;

		// Constructor
		Node(int key)
		{
			this.key = key;
			left = null;
			right = null;
		}
	}

	static Node root;
	static Node temp = root;

	// Inorder traversal of a binary tree
	static void inorder(Node temp)
	{
		if (temp == null)
			return;

		inorder(temp.left);
		System.out.print(temp.key + " ");
		inorder(temp.right);
	}

	// Function to delete deepest
	// element in binary tree
	static void deleteDeepest(Node root, Node delNode)
	{
		Queue&lt;Node&gt; q = new LinkedList&lt;Node&gt;();
		q.add(root);

		Node temp = null;

		// Do level order traversal until last node
		while (!q.isEmpty()) {
			temp = q.peek();
			q.remove();

			if (temp == delNode) {
				temp = null;
				return;
			}
			if (temp.right != null) {
				if (temp.right == delNode) {
					temp.right = null;
					return;
				}
				else
					q.add(temp.right);
			}

			if (temp.left != null) {
				if (temp.left == delNode) {
					temp.left = null;
					return;
				}
				else
					q.add(temp.left);
			}
		}
	}

	// Function to delete given element
	// in binary tree
	static void delete(Node root, int key)
	{
		if (root == null)
			return;

		if (root.left == null && root.right == null) {
			if (root.key == key) {
				root = null;
				return;
			}
			else
				return;
		}

		Queue&lt;Node&gt; q = new LinkedList&lt;Node&gt;();
		q.add(root);
		Node temp = null, keyNode = null;

		// Do level order traversal until
		// we find key and last node.
		while (!q.isEmpty()) {
			temp = q.peek();
			q.remove();

			if (temp.key == key)
				keyNode = temp;

			if (temp.left != null)
				q.add(temp.left);

			if (temp.right != null)
				q.add(temp.right);
		}

		if (keyNode != null) {
			int x = temp.key;
			deleteDeepest(root, temp);
			keyNode.key = x;
		}
	}

	// Driver code
	public static void main(String args[])
	{
		root = new Node(10);
		root.left = new Node(11);
		root.left.left = new Node(7);
		root.left.right = new Node(12);
		root.right = new Node(9);
		root.right.left = new Node(15);
		root.right.right = new Node(8);

		System.out.print("Inorder traversal "
						+ "before deletion:");
		inorder(root);

		int key = 11;
		delete(root, key);

		System.out.print("\nInorder traversal "
						+ "after deletion:");
		inorder(root);
	}
}
</code>
</pre>
            </li>
        </ol>
    </div>
    </div>
    <!-- Footer -->
    <footer class="text-lg-start bg-dark text-muted footer-dark mt-5" style="background-color: rgb(1,4,45) !important;">
        <!-- Section: Social media -->
        <section class="d-flex justify-content-lg-between p-4 border-bottom" style="color: white">
            <!-- Left -->
            <div class="me-5 d-none d-lg-block" style="font-size: 1.7em;">
                <span>Get connected with us on social networks:</span>
            </div>
            <!-- Left -->
            <!-- Right -->
            <div>
                <!-- Facebook -->
                <a class="btn text-white btn-floating m-1" style="background-color: #3b5998" href="#!" role="button"><i
                        class="bi bi-facebook"></i></a>
                <!-- Twitter -->
                <a class="btn text-white btn-floating m-1" style="background-color: #55acee" href="#!" role="button"><i
                        class="bi bi-twitter"></i></a>
                <!-- Google -->
                <a class="btn text-white btn-floating m-1" style="background-color: #dd4b39" href="#!" role="button"><i
                        class="bi bi-google"></i></a>
                <!-- Instagram -->
                <a class="btn text-white btn-floating m-1" style="background-color: #ac2bac" href="#!" role="button"><i
                        class="bi bi-instagram"></i></a>
                <!-- Linkedin -->
                <a class="btn text-white btn-floating m-1" style="background-color: #0082ca"
                    href="https://www.linkedin.com/in/mr-soham-manjrekar/" role="button"><i
                        class="bi bi-linkedin"></i></a>
                <!-- Github -->
                <a class="btn text-white btn-floating m-1" style="background-color: #333333"
                    href="https://github.com/sohammanjrekar" role="button"><i class="bi bi-github"></i></a>
            </div>
            <!-- Right -->
        </section>
        <!-- Section: Social media -->
        <!-- Section: Links  -->
        <section class="links" style="color: white">
            <div class="container text-md-start mt-5">
                <!-- Grid row -->
                <div class="row mt-3">
                    <!-- Grid column -->
                    <div class="col-md-8 col-lg-8 col-xl-8 mx-auto mb-4">
                        <!-- Content -->
                        <h2 class="text-uppercase fw-bold mb-4">
                            <i class="bi bi-gem me-3"></i>Cheatbook
                        </h2>
                        <p>
                            <li>Quick reference</li>
                            <li>Be productive after learning a new thing
                            </li>
                            <li>Quickly recall when forget some syntax</li>
                            <li>Use snippets for rapid development</li>
                        </p>
                    </div>

                    <!-- Grid column -->
                    <div class="col-md-4 col-lg-4 col-xl-4 mx-auto mb-md-0 mb-4" style="font-size: 1.3em;">
                        <!-- Links -->
                        <h2 class="text-uppercase fw-bold mb-4">Contact</h2>
                        <p><i class="bi bi-house-door me-3"></i>Badlapur,mumbai</p>
                        <p><i class="bi bi-envelope me-3"></i> mrsohammanjrekar@gmail.com</p>
                        <p><i class="bi bi-phone me-3"></i> +91 7045208474</p>
                        <p><i class="bi bi-whatsapp me-3"></i> +91 7045208474</p>
                    </div>
                    <!-- Grid column -->
                </div>
                <!-- Grid row -->
            </div>
        </section>
        <!-- Section: Links  -->
        <!-- Copyright -->
        <div class="text-center p-4" style="background-color: rgba(0, 0, 0, 0.05);color:white;word-spacing: 3px;">
            © 2022 Copyright:
            <a class="text-reset fw-bold" href="https://github.com/sohammanjrekar">cheatbook.com</a> created by Soham
            Manjrekar
        </div>
        <!-- Copyright -->
        <a class="js-scroll-trigger scroll-to-top rounded" href="#page-top"><i class="fa fa-angle-up"></i></a>
    </footer>
    <!-- Footer -->
    <!-- Footer -->
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js" type="text/javascript"></script>
    <script src="../../myDesigns/assets/js/jquery.min.js"></script>
    <script src="../../myDesigns/assets/bootstrap/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.4.1/jquery.easing.min.js"></script>
    <script src="../../myDesigns/assets/js/stylish-portfolio.js"></script>
</body>

</html>